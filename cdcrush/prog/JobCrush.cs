using cdcrush.lib;
using cdcrush.lib.app;
using cdcrush.lib.task;

using System;
using System.IO;


namespace cdcrush.prog
{
	
	
// Every Crush Job runs with these input parameters
public struct CrushParams
{	
	public string inputFile;	// The CUE file to compress
	public string outputDir;	// Output Directory.
	public string cdTitle;		// Custom CD TITLE
	public Tuple<int,int> audioQuality;	// Tuple<AudioCodecID, Bitrate/Index> !!
	public string cover;			// Cover image for the CD, square
	public int compressionLevel;	// Describe the compression level, 0-10?
	public int expectedTracks;		// In order for the progress report to work. set num of CD tracks here.
	
	// : Internal Access : ----

	// Keep the CD infos of the CD, it is going to be read later
	public CueReader cd {get; internal set;}
	// Filesize of the final archive
	public int crushedSize {get; internal set;}
	// Temp dir for the current batch, it's autoset, is a subfolder of the master TEMP folder.
	internal string tempDir;
	// Final destination ARC file, autogenerated from CD TITLE
	internal string finalArcPath;
	// If true, then all the track files are stored in temp folder and safe to delete
	internal bool flag_sourceTracksOnTemp;
	// True on `jobconvert`
	internal bool flag_convert_only;

}// --


/// <summary>
/// A collection of tasks, that will CRUSH a cd,
/// Tasks will run in order, and some will run in parallel
/// </summary>
class JobCrush:CJob
{
	// --
	public JobCrush(CrushParams p):base("Compress CD")
	{
		// Check for input files
		// :: --------------------
			if(!CDCRUSH.check_file_(p.inputFile,".cue")) {
				fail(msg:CDCRUSH.ERROR);
				return;
			}

			if(string.IsNullOrEmpty(p.outputDir)) {
				p.outputDir = Path.GetDirectoryName(p.inputFile);
			}

			if(!FileTools.createDirectory(p.outputDir)) {
				fail(msg: "Can't create Output Dir " + p.outputDir);
				return;
			}

			p.tempDir = Path.Combine(CDCRUSH.TEMP_FOLDER,Guid.NewGuid().ToString().Substring(0, 12));
			if(!FileTools.createDirectory(p.tempDir)) {
				fail(msg: "Can't create TEMP dir");
				return;
			}

		// -
		p.flag_convert_only = false;

		// IMPORTANT!! sharedData gets set by value, NOT A POINTER, do not make changes to p after this
		jobData = p;

		// 
		hack_setExpectedProgTracks(p.expectedTracks + 3);

		// --
		// - Read the CUE file ::
		add(new CTask((t) =>
		{
			var cd = new CueReader();
			jobData.cd = cd;

			if(!cd.load(p.inputFile)) {
				t.fail(msg:cd.ERROR);
				return;
			}

			// Meaning the tracks are going to be extracted in the temp folder
			jobData.flag_sourceTracksOnTemp = (!cd.MULTIFILE && cd.tracks.Count>1);

			// In case user named the CD, otherwise it's going to be the same
			if(!string.IsNullOrWhiteSpace(p.cdTitle))
			{
				cd.CD_TITLE = FileTools.sanitizeFilename(p.cdTitle);
			}

			// Real quality to string name
			cd.CD_AUDIO_QUALITY = CDCRUSH.getAudioQualityString(p.audioQuality);

			// Generate the final arc name now that I have the CD TITLE
			jobData.finalArcPath = Path.Combine(p.outputDir, cd.CD_TITLE + ".arc");

			t.complete();

		}, "-Reading"));
		
		// - Cut tracks
		// ---------------------------
		add(new TaskCutTrackFiles());

		// - Compress tracks
		// ---------------------
		add(new CTask((t) =>
		{
			CueReader cd = jobData.cd;
			foreach(CueTrack tr in cd.tracks) {
				addNextAsync(new TaskCompressTrack(tr));
			}//--
			t.complete();
		}, "-Preparing"));


		// Create Archive
		// Add all tracks to the final archive
		// ---------------------
		add(new CTask((t) => {
			CueReader cd = jobData.cd;

			// -- Get list of files::
			System.Collections.ArrayList files = new System.Collections.ArrayList();
			foreach(var tr in cd.tracks) {
				files.Add(tr.workingFile); // Working file is valid, was set earlier
			}

			// Compress all the track files
			var arc = new FreeArc(CDCRUSH.TOOLS_PATH);
			t.handleCliReport(arc);
			arc.compress((string[])files.ToArray(typeof(string)), jobData.finalArcPath, p.compressionLevel);
			arc.onProgress = (pr) => t.PROGRESS = pr;
			t.killExtra = () => arc.kill();

		}, "Compressing"));


		// - Create CD SETTINGS and push it to the final archive
		// ( I am appending these files so that they can be quickly loaded later )
		// --------------------
		add(new CTask((t) =>
		{
			CueReader cd = jobData.cd;

			#if DEBUG
				LOG.log(cd.getDetailedInfo());
			#endif

			string path_settings = Path.Combine(p.tempDir, CDCRUSH.CDCRUSH_SETTINGS);
			if(!cd.saveJson(path_settings))
			{
				t.fail(msg: cd.ERROR);
				return;
			}
	
			// - Cover Image Set?
			string path_cover;
			if(p.cover!=null) {
				path_cover = Path.Combine(p.tempDir,CDCRUSH.CDCRUSH_COVER);
				File.Copy(p.cover,path_cover);
			}else {
				path_cover = null;
			}

			// - Append the file(s)
			var arc = new FreeArc(CDCRUSH.TOOLS_PATH);
			t.handleCliReport(arc);
			arc.appendFiles(new string[]{path_settings, path_cover},jobData.finalArcPath);

			t.killExtra = () => arc.kill();

		}, "Finalizing"));

		// - Get post data
		add(new CTask((t) =>
		{
			var finfo = new FileInfo(jobData.finalArcPath);
			jobData.crushedSize = (int)finfo.Length;
			t.complete();

		}, "-Finalizing"));

		// -- COMPLETE --

	}// -----------------------------------------

	/// <summary>
	/// Called on FAIL / COMPLETE / PROGRAM EXIT
	/// Clean up temporary files
	/// </summary>
	protected override void kill()
	{
		base.kill();

		if(CDCRUSH.FLAG_KEEP_TEMP) return;

		// - Cleanup
		CrushParams p = jobData;
		if (p.tempDir != p.outputDir)  // NOTE: This is always a subdir of the master temp dir
		{ 
			try
			{
				Directory.Delete(p.tempDir, true);
			}
			catch(IOException)
			{
				// do nothing
			}
		}// --	
	}// -----------------------------------------

}// --
}// --
